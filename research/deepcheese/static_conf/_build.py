import logging
import pathlib
import string
import tomllib
import typing
import datetime


def build():
    """Build config.py from config.toml"""
    project_config = _load_config_from_pyproject()

    config_path = project_config.get("config_path")
    skeleton_path = project_config.get("skeleton_path")

    if config_path is None:
        config_path = pathlib.Path(".").parent / "config.toml"

    if skeleton_path is None:
        skeleton_path = pathlib.Path(".").parent / "config.toml"

    skeleton = _load_config_from_toml(skeleton_path)

    build_file_path = pathlib.Path(__file__).parent / "_config.py"

    file = open(build_file_path, "w")

    _write_import_statement(file)
    _recursive_write(file, skeleton, "config", 0)
    _write_footer(file, config_path)


def _load_config_from_pyproject() -> dict | None:
    """
    load config file path from pyproject.toml
    :return: config if found, None otherwise
    """
    pyproject_path = pathlib.Path(".").parent / "pyproject.toml"

    try:
        with open(pyproject_path) as file:
            pyproject = tomllib.loads(file.read())
    except FileNotFoundError:
        logging.error(f"File not found: {pyproject_path}")
        return None

    config = pyproject.get("tool", {}).get("static_conf", {})

    if config is None:
        logging.error("static_conf is not defined in pyproject.toml")

    return config


def _load_config_from_toml(config_path: pathlib.Path) -> dict | None:
    """
    Load config from toml file
    :param config_path: path to toml file
    :return: config if found, None otherwise
    """
    try:
        with open(config_path) as file:
            skeleton = tomllib.loads(file.read())
        return skeleton
    except FileNotFoundError:
        logging.error(f"File not found: {config_path}")
        return None


def _write_import_statement(handler: typing.TextIO):
    """
    Write import statement of config.py
    :param handler: file handler
    """
    handler.write("# This file is generated by config/build.py\n")
    handler.write("import dataclasses\n")
    handler.write("import tomllib\n")
    handler.write("import datetime\n")
    handler.write("from ._singleton import Singleton\n\n\n")


def _get_class_name(key: str) -> str:
    """Get class name from key"""
    return "_" + string.capwords(key, "_").replace("_", "")


def _write_class_header(handler: typing.TextIO, name: str, indent: int):
    """
    Write class header
    :param handler: file handler
    :param name: class name
    :param indent: indentation
    """
    handler.write(" " * indent + "@dataclasses.dataclass\n")

    if name == "config" and indent == 0:
        handler.write(" " * indent + f"class Config(metaclass=Singleton):\n")
    else:
        handler.write(" " * indent + f"class {_get_class_name(name)}:\n")


def _parse_type(value: typing.Any) -> str:
    """
    Parse type of value
    :param value: type of value
    :return: str representation of type
    """
    if isinstance(value, str):
        return "str"
    elif isinstance(value, int):
        return "int"
    elif isinstance(value, float):
        return "float"
    elif isinstance(value, bool):
        return "bool"
    elif isinstance(value, datetime.time):
        return "datetime.time"
    else:
        return str(type(value))


def _recursive_write(handler: typing.TextIO, skeleton: dict, classname: str, indent: int):
    """
    Recursive write class
    :param handler: file handler
    :param skeleton: config skeleton
    :param classname: class name
    :param indent: indentation
    """
    dict_target = []
    _write_class_header(handler, classname, indent)

    for key, value in skeleton.items():
        if isinstance(value, dict):
            _recursive_write(handler, value, key, indent + 4)
            handler.write("\n")
            dict_target.append(key)

    for key, value in skeleton.items():
        if key in dict_target:
            handler.write(" " * (indent + 4) + f"{key}: {_get_class_name(key)}\n")
        else:
            handler.write(" " * (indent + 4) + f"{key}: {_parse_type(value)}\n")

    handler.write("\n")
    _write_init_function(handler, skeleton, indent + 4)


def _write_init_function(handler: typing.TextIO, skeleton: dict, indent: int):
    """
    Write __init__ function in class
    :param handler: file handler
    :param skeleton: config skeleton
    :param indent: indentation
    :return:
    """
    handler.write(" " * indent + "def __init__(self, skeleton: dict = None):\n")

    for key, value in skeleton.items():
        if isinstance(value, dict):
            handler.write(" " * (indent + 4) + f"self.{key} = self.{_get_class_name(key)}(skeleton['{key}'])\n")
        else:
            handler.write(" " * (indent + 4) + f"self.{key} = skeleton.get('{key}')\n")


def _write_footer(handler: typing.TextIO, config_path: str):
    """write footer of config.py to use Singleton pattern"""
    handler.write(f'\n\nwith open("{config_path}") as file:\n    _ = Config(tomllib.loads(file.read()))\n')
